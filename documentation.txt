Команды для терминала:

npx create-react-app . - Создаёт, проект на React.
npm i sass - Установка Sass библиотеки
npm i axios - Установка Axios библиотеки, работа с сервером (запросы, отправка)
npm i react-router-dom - Установка Reac router библиотеки, для рутинга по сайту.


Позиционирование элемента

    console.log(e.clientX)
    console.log(e.clientY)
    console.log(e.pageX)
    console.log(e.pageY)

Количество прокрученных пикселей

    console.log(window.pageYOffset); //Сверху-вниз
    console.log(window.pageXOffset); //Слева-направо

Получение координат элемента
    Относительно документа, абсолютное положение
    getBoundingClientRect().top + window.pageYOffset 
    getBoundingClientRect().left + window.pageXOffset
    Относительно окна браузера
    console.log(e.currentTarget.getBoundingClientRect())
    Можно получить:
    top
    bottom
    left
    right
    width
    height

Размеры экрана и рабочей области браузера

    console.log(document.documentElement.clientWidth) Ширина страницы без скролла
    console.log(document.documentElement.clientHeight) Высота страницы без скролла
    console.log(window.innerWidth) //Размер рабочей области браузера по горизонтали
    console.log(window.innerHeight) //Размер рабочей области браузера по вертикале
    console.log(window.outerWidth) Разрешение экрана по горизонтали
    console.log(window.outerHeight) Разрешение экрана по вертикале

Развёртывание базы данных в компонент016

    {store.map(card =>
        <Component>
        <children>
        </Component>
    )}

Развёртывание базы данных в компонент, если данные приходят после нажатия

    {(props.storage === undefined)
                    ? <h1>Загрузка данных</h1>
                    : props.storage.label.map(list => 
                        <Component>
                            {text}
                        </Component>
                    )}

Работа с элементом, где 1 получает заданный id элемента, а 2 выполняет манипуляции на основе полученного id
1. onClick={action(id)}
2.
const action = id => {
     const click = () => {
        console.log(id)
    }
    return (click)
}

Функция вызова самой себя
const getOnClick = id => {
        const onClick = async () => {
            // console.log(id)
            const response = await axios.get(`http://localhost:5000/api/ancestries/${id}`)
            console.log(response.data)
            props.setStorage(response.data)
            setActiveItemId(id)
        }
        return (onClick)
    }

Функция Callback
const [visibleFade, setVisibleFade] = useState(false)
    const childToParent = (childdata) => { //Функция callback, где childToParent - функция переваемая через аргумент дочернему компоненту, childdata - данные получаемые при выполнение иной функции в компоненте.
        console.log(childdata) //childdata - может принять данные, обьекты, массивы, функции.
        setVisibleFade(childdata)
    } 
    return ( 
        <>
            <Fade
            visibleFade={visibleFade}
            />
            <Head
            childToParent={childToParent}
            />
            <HomeContent/>
        </>
        );

Перебор массива и помещение полученного массива в состояние

    const [storageCard, setStorageCard] = useState({})
    const items = store.find(
                item => e.currentTarget.id === item.idName
            )
            setStorageCard(items)

Пример прописывания стиля через props

    style = {{margin: (props.margin)}}

Пример прописывания класса через props
    
    //Условие через useState
    className = {`${classes.name} ${props.state?classes.active:""}`}
    
    //Тернарное условие, со сравнинием и если получается true применяетя класс
    className={`${props.id === props.activeItemId ? classes.marker : ''}`}

Закрытие окна по Esc
    function keyDown (event) {
            console.log(event.key)
            if (event.key === 'Escape') {
                setSidebarActive(false)
            }
        }
    Обязательно надо прописать на элемент tabIndex, так как onKeyDown работает только при выделеменом элементе
    tabIndex = {0} //Выделение элемента для работы onKeyDown
    onKeyDown ={props.escFalse} //Закрытие выпадающего меню по Escape

Прокидывание props, сквозь компоненты

    const [theme, setTheme] = useState(true)
    
      return (
        // Прокидывание состоняие в кнопку
        <Theme.Provider
        value={{theme, setTheme}} Что прокидывается
        >
          <div className={`${"grid"} ${theme?"light":"dark"}`}>
            <RouterProvider router={router}/>
          </div>
        </Theme.Provider>
      )

Перемещение окна авторизации при скролле
    let counterY = window.pageYOffset; // Счётчик прокрутки страницы
    let accountCssTop = getComputedStyle(accountBody).top; // Значение top по умолчанию
    document.addEventListener("scroll", function() {
        if (window.pageYOffset > 0) {
            accountBody.style.top = `${parseInt(accountCssTop)+window.pageYOffset}px`;
        }
    })

Активация всплывающего окна относительно родительского блока
React код:
const [activeBigCard, setActiveBigCard] = useState(false)
    const [storageCard, setStorageCard] = useState({})
    const [coordinates, setCoordinates] = useState({})

    const loadBigCard = (e) => {
        const items = store.find(
            item => e.currentTarget.id === item.idName
        )
        setStorageCard(items)
        
        const coordin = Coordinates(e)
        const topChange = coordin.top
        const leftChange = coordin.left
        const botChange = coordin.bottom
        const rightChange = coordin.right
        const widthChange = coordin.width
        const heightChange = coordin.height
        
        setCoordinates({topChange, leftChange, botChange, rightChange, widthChange, heightChange})

        setActiveBigCard(!activeBigCard)
    }

//Рандомизация массива
//Один из распространенных способов рандомизации элементов массива - это использование алгоритма Фишера-Йетса (также известного как алгоритм тасования Кнута)
    function shuffleArray(array) { 
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }



Скрипт:
export const Coordinates = (e) => {
    var id = e.currentTarget.id
    var top = e.currentTarget.getBoundingClientRect().top
    var bottom = e.currentTarget.getBoundingClientRect().bottom
    var left = e.currentTarget.getBoundingClientRect().left
    var right = e.currentTarget.getBoundingClientRect().right
    var width = e.currentTarget.getBoundingClientRect().width
    var height = e.currentTarget.getBoundingClientRect().height

    //1
    if (id === "cardAnc") {
        return ({left, top})
    }
    //2
    if (id === "cardClass") {
        left = left - width/2
        return ({left, top})
    }
    //3
    if (id === "cardSpell") {
        right = window.innerWidth - right
        return ({right, top})
    }
    //4
    if (id === "cardFeats") {
        top = top - height/2 
        return ({left, top})
    }
    //5
    if (id === "cardEquip") {
        left = left - width/2
        top = top - height/2 
        return ({left, top})
    }
    //6
    if (id === "cardItems") {
        right = window.innerWidth - right
        top = top - height/2 
        return ({right, top})
    }
    //7
    if (id === "cardAbill") {
        bottom =  window.innerHeight - bottom
        return ({left, bottom})
    }
    //8
    if (id === "cardRule") {
        left = left - width/2
        bottom =  window.innerHeight - bottom
        return ({left, bottom})
    }
    //9
    if (id === "cardCover") {
        right = window.innerWidth - right
        bottom =  window.innerHeight - bottom
        return ({right, bottom})
    }
}
Элемент:
<div
        style={{top: (props.coordinates.topChange), left: (props.coordinates.leftChange), bottom: (props.coordinates.botChange), right: (props.coordinates.rightChange), width: (props.coordinates.width), height: (props.coordinates.height)}} 
        className = {`${classes.card} ${props.bigCard?classes.active:""}`}
        >
            <Link to={props.storage.link}>
                {props.storage.name}
            </Link>
            <div className={classes.list}>
                {(props.storage.label === undefined)
                ? <h1>Загрузка данных</h1>
                : props.storage.label.map(list => 
                    <ListItem
                    link = {props.storage.link}
                    >
                        {list}
                    </ListItem>
                )
                }
            </div>
        </div>

dice
    //d2
    console.log(Math.floor(Math.random()*2+1));
    //d4
    console.log(Math.floor(Math.random()*4+1));
    //d6
    console.log(Math.floor(Math.random()*6+1));
    //d8
    console.log(Math.floor(Math.random()*8+1));
    //d12
    console.log(Math.floor(Math.random()*12+1));
    //d20
    console.log(Math.floor(Math.random()*20+1));
    //d100
    console.log(Math.floor(Math.random()*100+1));
    //2d100
    console.log(Math.floor((Math.random()*100+1)+(Math.random()*100+1)));
